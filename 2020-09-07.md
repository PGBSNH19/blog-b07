### 2020-09-07


## Vad vi har installerat

Vi behöver Docker Desktop:
https://docs.docker.com/get-docker/


## Köra en .NET web applikation i en Docker Container

Börjar med att skapa en ny mapp, och kliv in i den:
```
mkdir NetCore-Docker
cd ./NetCore-Docker
```

Vi skapar en ny mvc applikation och provkör applikationen (valfritt) för att se att den fungerar och vad vi förväntar oss i slutändan:
```
dotnet new mvc
dotnet run
```

Sedan behöver man en Dockerfil (Dockerfile) och det finns åtminstone 2 sätt att lösa det på, det första är att öppna projektet i Visual Studio. Högerklicka sedan på Projekt > Add > Docker Support och välj att spara Dockerfilen i samma map som projektet. Så nu har man en redo Dockerfile.

### Skriva Dockerfile manuellt
Ett annat alternativ att skapa Dockerfile är att skapa den manuellt och fylla i: 
``` 
# Hämta ner image av SoftwareDevelopmentKit (Från dockerhubs) och lägg i /app
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build-env
WORKDIR /app

# dotnet restore uppdaterar alla dependencies
COPY *.csproj ./
RUN dotnet restore

# Kompilera programmet
COPY . ./
RUN dotnet publish -c Release -o out

# Spara ner image, kopiera projet in i vår folder /app och ange entrypoint för vart programmet ska starta ifrån
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1
WORKDIR /app
COPY --from=build-env /app/out .
ENTRYPOINT ["dotnet", "SimpleWebHalloWorld.dll"]
```

Nästa steg ifrån terminalen är att bygga en image genom kommandot: 
```
docker build -t myapp .
``` 
-t anger namn för vår app, om man inte anger -t så får image ett auto-genererat namn - och . anger ifrån nuvarande directory.

Man kan nu prova att skriva `docker images` vilket ska ge en lista på images, där överst vår **myapp** ska finnas.

Nu vill vi köra vår container: 
```
docker run -d -p 8080:80 --name mycontainer myapp
```
-d säger att köra det i bakgrunden, -p anger port 8080:80 där 8080 är utgångsport och 80 är ingångsport. --name är det namnet som vår container ska heta.

Sedan skriver vi kommandot `docker ps` för att se lista alla containers. Så nu kan man gå in på localhost:8080 för att se vår web applikation!


## Docker Compose, vad innehåller den?

Först och främst ska en Docker Compose innehålla  en fil, `docker-compose.yml` som ska hålla instruktioner för hur alla beståndsdelar ska köras och på vilka portar de ska kommunicera, med mera

I vårt exempel demonstrerar vi hur man kan använda en Docker Compose för att köra 2 appar. 

Först skapar vi 2 sepparata program, i undermappar,  ifrån vårat projekts rotmap:
```
dotnet new mvc --name hello1
dotnet new mvc --name hello2
```
Sedan går vi in och gör lite småförändringar så att de skiljer sig åt. Sedan ge vardera projekt en Dockerfile, bygg upp den likt föregående [exempel](#skriva-dockerfile-manuellt)

Sedan gör bygger man upp två images, en för vardera projekt - se till att stå i rätt projektmapp för varje kommand:
```
docker build -t hello1 .
docker build -t hello2 .
```

Sedan går vi ut till rotmappen. I filen `docker-compose.yml` skriver vi nu...
```
version: '3'
services:
  hello1:
    image: "hello1"
    ports:
      - "5001:80"
  hello2:
    image: "hello2"
    ports:
      - "5002:80"
```
Skriver man sedan kommandot `docker-compose up` så ska bägge apparna köras. I detta fall kommer hello1 köras på port 5001 (localhost:5001) och hello2 köras på port 5002 (localhost:5002).

Lägg märke till att `image:` använder en stillbild av appen. Man kan istället skriva `build: /hello1 .` där man hänvisar till appens plats för att bygga på senaste version istället. 


## Att pusha Container till Azure Container Instance

Vi har lyckats göra det med 2 olika metoder - ett via terminalen och ett med hjälp utav Visual Studio - och  vi kommer här gå igenom via terminalen.

Man loggar först in på azure med `az login` och sedan skapa en resursgrupp:
```
az group create --name <namn på resursgrupp> --location northeurope
```

Nästa sak man behöver är en **Azure Container Registry** och det kan man skapa genom kommandot: 
```
az acr create --resource-group <namn på resursgrupp> --name <namn på register> --sku Basic --admin-enabled true
```

Nästa steg är  att logga in på vårat register `az acr login --name <namn på register>`

Nästa steg var något som förbryllade oss först då det visar sig att ens Images behöver ha namn som återspeglar vårat registry. Alltså får man byta namn på sin Image:
`docker tag hello1:mytag1 <namn på register>/<namn på resursgrupp>:<tagnamn>`
Vad som här sker är att vi byter namn på vår Image som först har namnet `hello1` med tagen `mytag1`, till namnet `registernamn/resursgruppnamn` som får en godtycklig tag, till exempel `version1`. Det visar sig även att det här inte byter namn, utan snarare gör en klon av Image.

Sedan behöver vi adressen till vårat register som vi kan få fram genom
```
az acr list --resource-group <namn på resursgrupp> --query "[].{acrLoginServer:loginServer}" --output table
```
Det ger en utskrift som: `resursgruppnamn.azurecr.io`

Slutligen vill vi pusha upp, och det gör vi med:
```
docker push resursgruppnamn.azurecr.io/containernamn:tagnamn
```
